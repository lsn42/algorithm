11076 浮点数的分数表达（优先做）
时间限制:1000MS  代码长度限制:10KB
提交次数:0 通过次数:0

题型: 编程题   语言: G++;GCC;VC
Description
在计算机中，用float或double来存储小数有时不能得到精确值，若要精确表达一个浮点数的计算结果，
最好用分数来表示小数，有限小数或无限循环小数都可以转化为分数，无限循环小数的循环节用括号标记出来。如：
0.9 = 9/10
0.(3) = 0.3(3) = 0.3(33) = 1/3

当然一个小数可以用好几种分数形式来表示，我们只感兴趣最简的分数形式(即分母最小)，如：
0.3(33) = 1/3 = 3/9

因为任何一个数都可以转化为一个整数和一个纯小数之和，整数部分较为简单无需做额外处理，只要将纯小数部分转
化为分数形式，整数部分的分数部分就很简单了。

现在给定一个正的纯小数（这个纯小数为有限小数或无限循环小数），请你以最简分数形式来返回这个纯小数。



输入格式
给定一个纯小数，若是无限循环小数，用括号标记循环节，输入小数表达不超过100个字符。

说明：这里如果觉得高精度数有难度，先考虑用64位整数来求解吧。测试数据没有太长，位数不超过64位整数表示范围。
即，你用64位整数做，可通过此题。


输出格式
输出：化为最简分数形式，分子在前，分母在后，中间空格连接。


输入样例
0.3(33)


输出样例
1 3


提示

此题涉及如下几个问题：


一、字符串输入的问题

此题采用字符串接收输入，大家在接受数据的时候，不要用(c=getchar())!='\n'诸如此类一个字符一个字符接受，然后
判断是否是回车符号来结束输入，这样的方式在你本机运行不会有问题，但OJ系统中会有错误，无法输出结果，因为OJ的
测试平台行末并非'\n'字符。这里接受数据用scanf的%s，或cin等，会自动判别结束字符的，你就不要在你程序里专门去
判别或吸收回车字符。
char a[105];
scanf("%s",a); 或cin >> a;


二、高精度或64位整数表示的问题

此题题目规定:输入小数表达不超过100个字符。
如此长的数,本意要大家用高精度数的运算来求解.
但后台测试数据也没有做如此之长（或者说我把最长的几组测试数据都屏蔽了）,
放松一些吧,用64位整数也是允许通过此题的！

实现上，所有分子分母的变量，以及求最大公约数，都须用64位整数。
编译环境不同，对64位整数的定义和输入输出略有不同：
1） gnu gcc/g++ 中long long类型，或unsigned long long,
输入输出用cin和cout直接输出。
long long a;
cin >> a;
cout << a;

也可以使用:(注意一下,本OJ系统的gcc/g++不支持64位整数以"%I64d"形式输出,
但标准gnu gcc是支持如下的,在codeblocks上可以无误运行)
long long a;
scanf("%I64d",&a);
printf("%I64d",a);

2） vc中用__int64类型，或unsigned __int64
__int64 a;
scanf("%I64d",&a);
printf("%I64d",a);
vc下，64整数不要用cin和cout来输入输出，据说vc下64位整数兼容不好，会出错！大家可测试一下如下程序
在vc下是否会出错？
__int64 a;
cin >> a;
cout << a;


三、本题的解题思路

考虑输入的是纯小数，先暂时不考虑分子和分母有公因子的情况。
(1) 假设有限小数：X = 0.a1a2…an，式中的a1,a2,…,an都是0~9的数字。
        X = 0.a1a2…an = a1a2…an/10^n

(2) 假设无限循环小数：X = 0.a1a2…an(b1b2…bm)，式中的a1,a2,…,an, b1,b2,…,bm都是0~9的数字，括号为循环节。
第一步，先将X化为只有循环部分的纯小数。
        X = 0.a1a2…an(b1b2…bm)
        (10^n)*X = a1a2…an + 0.(b1b2…bm)
        X = (a1a2…an + 0.(b1b2…bm)) / (10^n)
上式中，a1a2…an是整数部分，容易解决。重点考虑小数部分0.(b1b2…bm)如何化为分数形式，再加上整数部分即可。
第二步，考虑Y = 0.(b1b2…bm)，将Y化为分数，
        (10^m)*Y = b1b2…bm + 0.(b1b2…bm)
        ((10^m)-1)*Y = b1b2…bm
        Y = b1b2…bm / ((10^m)-1)
将第二步的Y带入第一步的X，可得：
        X = (a1a2…an+Y)/(10^n) = ((a1a2…an)*((10^m)-1) + (b1b2…bm)) / (((10^m)-1)*(10^n))

此时，可以将任何一个有限小数或无限循环小数，化为分数表示，分数的分子和分母如上分析的公式。但此时
的分子分母未必是最简化的，对分子分母再进行约分，删去公共的因子，A/B = (A/GCD(A,B))/(B/GCD(A,B))，
化为简单形式。 这里，GCD(A,B)表示A和B的最大公约数。


-------------------------------------------------------------------------------------

题目给的例子0.3(33)按照如上公式分析看看是否是1/3。

这里设输入的数为X。
X = 0.3(33)
10X = 3.(33)
X = 3/10 + 0.(33)/10     //这一步目的化成只有循环节的小数，比如：0.(33)，而把原数循环节前面的数都变
                         //为有限小数的部分（因为有限小数更容易处理），现在需要重点考虑只有循环节部
                         //分的纯小数怎么转化为分数即可。

另：Y = 0.(33)
（10^2）Y = 33 + Y
（10^2 - 1）Y = 33
Y = 33/99     //将这个Y代入上式求解X的分数表达

则初始数据：X = 3/10 + (1/10)*Y
X = 3/10 + (1/10)*(33/99)
X = 330/990

将分子分母约去最大公约数得：X = 1/3



作者 zhengchan

Version: 3