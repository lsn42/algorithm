17088 分治法求众数（优先做）
时间限制:1000MS  代码长度限制:10KB
提交次数:0 通过次数:0

题型: 编程题   语言: G++;GCC;VC
Description
给定含有n个元素的多重集合S，每个元素在S中出现的次数称为该元素的重数。多重集S中重数最大的元素称为
众数。例如，S={1，2，2，2，3，5}。多重集S的众数是2，其重数为3。

求众数方法很多，现要求你用分治算法来试一试，并分析其效率。

编程任务：对于给定的由n个自然数组成的多重集S，采用分治算法编程计算S的众数及其重数。



输入格式
第1行多重集S中元素个数n；接下来的一行为集合S，有n个自然数。( n < 1000000 )


输出格式
结果输出：输出2个数，第1个数为众数，第2个为其重数。
当有多个同样重数的众数，优先输出数值更小的数的众数。


输入样例
6 
1 2 2 2 3 5


输出样例
2 3


提示

此题求众数，若数据规模n较小，则较为简单，解法较多。此题要求你用方法四，分治算法来实现。

解法一：（简单映射的解法）
用一个长度为最大元素值的数组作为n个元素出现重数的计数。这种方法时间复杂度为O(n)，但空间
复杂度较大些，空间依赖于原数组的规模。

解法二：（散列表映射的解法）
同解法一，只是采用散列表代替数组的映射，当散列表的负载因子小于0.5时，大部分情况下检索
长度小于2，但若负载因子超过0.5，散列表性能也将下降。

解法三：（排序法）
将n个元素排序，相同元素将出现到一起，对排序后的数组从左到右一遍扫描，边扫描边统计，
即可以找出具有最长相同元素序列的众数。此方法由于要排序，时间复杂度做不到线性，需
要O(nlogn)。空间上需求较少，除了原数组外，只需要记录从左扫过来的当前出现最多的元素
和当前出现最多元素出现的次数，可以认为空间需求O(1)。

解法四：（分治算法）
1，先求n个元素的中位数及其位置（可以用书本上随机基准元素的快速选择算法实现中位数选择），
然后以中位数做划分，划分出：比中位数小（含另外相等中位数分散在左段其间）的左段
和比中位数大（含另外相等中位数分散在右段其间）的右段，
此时要把数组中与中位数相同的数字靠拢，才可以统计中位数个数（中位数因相同可能存在多个），
要聚拢与选择出的中位数相等的其他分散在左段或右段中的其它中位数，还需对左段和右段一遍扫描，
将左段中最大元素往序列中间调（右调），右段中最小元素往序列中间调（左调），
这样聚拢中位数，并得到聚拢后中位数的个数；

2，此时数组被中间相等的中位数分开成两部分，此时有递归的条件了：
先看左边，若中位数的个数比左边这段短，说明左边可能找到重数更多的，所以对左边段的递归继续；
反之，如果左边这段的长度更短，就没有必要对左段继续递归。对右边那段数据采用同样的递归策略。
当左右段都找到同样重数（都大于中间中位数个数，且重数相等），优先输出左段的众数。

时间效率分析：因为递归的两个子段都能以接近1/2倍率缩短，最坏情况下左右两段都要递归，
所以T(n)=2T(n/2)+O(n) T(1)=1，因此T(n)=O(nlogn)。特别的，当中位数是主元素时（元素
个数大于等于1/2的元素称为主元素），只需要O(n)，一般情况下整个算法应该是介于O(n)和
O(nlogn)之间。
空间上，除了原数组以外无需太多辅助的空间。

以上方法，方法4在实现上比方法3麻烦很多，但效率上方法4略好于方法3，方法4的最坏情况基本同于方法3。



作者 zhengchan

Version: 5